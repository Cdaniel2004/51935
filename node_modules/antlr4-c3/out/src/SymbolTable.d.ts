import { ParseTree } from "antlr4ts/tree/ParseTree";
export declare class DuplicateSymbolError extends Error {
}
export declare enum MemberVisibility {
    Unknown = 0,
    Open = 1,
    Public = 2,
    Protected = 3,
    Private = 4,
    FilePrivate = 5,
    Library = 6
}
export declare enum Modifier {
    Static = 0,
    Final = 1,
    Sealed = 2,
    Abstract = 3,
    Deprecated = 4,
    Virtual = 5,
    Const = 6,
    Overwritten = 7
}
export declare enum TypeKind {
    Unknown = 0,
    Integer = 1,
    Float = 2,
    Number = 3,
    String = 4,
    Char = 5,
    Boolean = 6,
    Class = 7,
    Interface = 8,
    Array = 9,
    Map = 10,
    Enum = 11,
    Alias = 12
}
export declare enum ReferenceKind {
    Irrelevant = 0,
    Pointer = 1,
    Reference = 2,
    Instance = 3
}
export interface Type {
    name: string;
    baseTypes: Type[];
    kind: TypeKind;
    reference: ReferenceKind;
}
export interface SymbolTableOptions {
    allowDuplicateSymbols?: boolean;
}
export declare class FundamentalType implements Type {
    static readonly integerType: FundamentalType;
    static readonly floatType: FundamentalType;
    static readonly stringType: FundamentalType;
    static readonly boolType: FundamentalType;
    name: string;
    private typeKind;
    private referenceKind;
    constructor(name: string, typeKind?: TypeKind, referenceKind?: ReferenceKind);
    get baseTypes(): Type[];
    get kind(): TypeKind;
    get reference(): ReferenceKind;
}
export declare class Symbol {
    name: string;
    context?: ParseTree;
    readonly modifiers: Set<Modifier>;
    visibility: MemberVisibility;
    private theParent?;
    constructor(name?: string);
    get parent(): Symbol | undefined;
    get firstSibling(): Symbol;
    get previousSibling(): Symbol | undefined;
    get nextSibling(): Symbol | undefined;
    get lastSibling(): Symbol;
    get next(): Symbol | undefined;
    get root(): Symbol | undefined;
    get symbolTable(): SymbolTable | undefined;
    get symbolPath(): Symbol[];
    setParent(parent: Symbol | undefined): void;
    removeFromParent(): void;
    resolve(name: string, localOnly?: boolean): Promise<Symbol | undefined>;
    resolveSync(name: string, localOnly?: boolean): Symbol | undefined;
    getParentOfType<T extends Symbol>(t: new (...args: any[]) => T): T | undefined;
    qualifiedName(separator?: string, full?: boolean, includeAnonymous?: boolean): string;
}
export declare class TypedSymbol extends Symbol {
    type: Type | undefined;
    constructor(name: string, type?: Type);
}
export declare class TypeAlias extends Symbol implements Type {
    private targetType;
    constructor(name: string, target: Type);
    get baseTypes(): Type[];
    get kind(): TypeKind;
    get reference(): ReferenceKind;
}
export declare class ScopedSymbol extends Symbol {
    private childSymbols;
    constructor(name?: string);
    get directScopes(): Promise<ScopedSymbol[]>;
    get children(): Symbol[];
    get firstChild(): Symbol | undefined;
    get lastChild(): Symbol | undefined;
    clear(): void;
    addSymbol(symbol: Symbol): void;
    removeSymbol(symbol: Symbol): void;
    getNestedSymbolsOfType<T extends Symbol>(t: new (...args: any[]) => T): Promise<T[]>;
    getNestedSymbolsOfTypeSync<T extends Symbol>(t: new (...args: any[]) => T): T[];
    getAllNestedSymbols(name?: string): Promise<Symbol[]>;
    getAllNestedSymbolsSync(name?: string): Symbol[];
    getSymbolsOfType<T extends Symbol>(t: new (...args: any[]) => T): Promise<T[]>;
    getAllSymbols<T extends Symbol>(t: new (...args: any[]) => T, localOnly?: boolean): Promise<T[]>;
    getAllSymbolsSync<T extends Symbol>(t: new (...args: any[]) => T, localOnly?: boolean): T[];
    resolve(name: string, localOnly?: boolean): Promise<Symbol | undefined>;
    resolveSync(name: string, localOnly?: boolean): Symbol | undefined;
    getTypedSymbols(localOnly?: boolean): TypedSymbol[];
    getTypedSymbolNames(localOnly?: boolean): string[];
    symbolFromPath(path: string, separator?: string): Symbol | undefined;
    indexOfChild(child: Symbol): number;
    nextSiblingOf(child: Symbol): Symbol | undefined;
    previousSiblingOf(child: Symbol): Symbol | undefined;
    nextOf(child: Symbol): Symbol | undefined;
}
export declare class NamespaceSymbol extends ScopedSymbol {
}
export declare class BlockSymbol extends ScopedSymbol {
}
export declare class VariableSymbol extends TypedSymbol {
    value: any;
    constructor(name: string, value: any, type?: Type);
}
export declare class LiteralSymbol extends TypedSymbol {
    readonly value: any;
    constructor(name: string, value: any, type?: Type);
}
export declare class ParameterSymbol extends VariableSymbol {
}
export declare class RoutineSymbol extends ScopedSymbol {
    returnType?: Type;
    constructor(name: string, returnType: Type);
    getVariables(localOnly?: boolean): Promise<VariableSymbol[]>;
    getParameters(localOnly?: boolean): Promise<ParameterSymbol[]>;
}
export declare enum MethodFlags {
    None = 0,
    Virtual = 1,
    Const = 2,
    Overwritten = 4,
    SetterOrGetter = 8,
    Explicit = 16
}
export declare class MethodSymbol extends RoutineSymbol {
    methodFlags: MethodFlags;
}
export declare class FieldSymbol extends VariableSymbol {
    setter?: MethodSymbol;
    getter?: MethodSymbol;
}
export declare class ClassSymbol extends ScopedSymbol implements Type {
    isStruct: boolean;
    reference: ReferenceKind;
    readonly extends: ClassSymbol[];
    readonly implements: Array<ClassSymbol | InterfaceSymbol>;
    constructor(name: string, ext: ClassSymbol[], impl: Array<ClassSymbol | InterfaceSymbol>);
    get baseTypes(): Type[];
    get kind(): TypeKind;
    getMethods(includeInherited?: boolean): Promise<MethodSymbol[]>;
    getFields(includeInherited?: boolean): Promise<FieldSymbol[]>;
}
export declare class InterfaceSymbol extends ScopedSymbol implements Type {
    reference: ReferenceKind;
    readonly extends: Array<ClassSymbol | InterfaceSymbol>;
    constructor(name: string, ext: Array<ClassSymbol | InterfaceSymbol>);
    get baseTypes(): Type[];
    get kind(): TypeKind;
    getMethods(includeInherited?: boolean): Promise<MethodSymbol[]>;
    getFields(includeInherited?: boolean): Promise<FieldSymbol[]>;
}
export declare class ArrayType extends Symbol implements Type {
    readonly elementType: Type;
    readonly size: number;
    private referenceKind;
    constructor(name: string, referenceKind: ReferenceKind, elemType: Type, size?: number);
    get baseTypes(): Type[];
    get kind(): TypeKind;
    get reference(): ReferenceKind;
}
export declare class SymbolTable extends ScopedSymbol {
    readonly options: SymbolTableOptions;
    protected dependencies: Set<SymbolTable>;
    constructor(name: string, options: SymbolTableOptions);
    get info(): {
        dependencyCount: number;
        symbolCount: number;
    };
    clear(): void;
    addDependencies(...tables: SymbolTable[]): void;
    removeDependency(table: SymbolTable): void;
    addNewSymbolOfType<T extends Symbol>(t: new (...args: any[]) => T, parent: ScopedSymbol | undefined, ...args: any[]): T;
    addNewNamespaceFromPath(parent: ScopedSymbol | undefined, path: string, delimiter?: string): Promise<NamespaceSymbol>;
    addNewNamespaceFromPathSync(parent: ScopedSymbol | undefined, path: string, delimiter?: string): NamespaceSymbol;
    getAllSymbols<T extends Symbol>(t: new (...args: any[]) => T, localOnly?: boolean): Promise<T[]>;
    getAllSymbolsSync<T extends Symbol>(t: new (...args: any[]) => T, localOnly?: boolean): T[];
    symbolWithContext(context: ParseTree): Promise<Symbol | undefined>;
    symbolWithContextSync(context: ParseTree): Symbol | undefined;
    resolve(name: string, localOnly?: boolean): Promise<Symbol | undefined>;
    resolveSync(name: string, localOnly?: boolean): Symbol | undefined;
}
