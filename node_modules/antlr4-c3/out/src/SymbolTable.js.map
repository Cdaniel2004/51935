{"version":3,"file":"SymbolTable.js","sourceRoot":"","sources":["../../src/SymbolTable.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * This file is released under the MIT license.\n * Copyright (c) 2017, 2021, Mike Lischke\n *\n * See LICENSE file for more info.\n */\n\n/* eslint-disable max-classes-per-file */\n\nimport { ParseTree } from \"antlr4ts/tree/ParseTree\";\n\nexport class DuplicateSymbolError extends Error { }\n\nexport enum MemberVisibility {\n    /** Not specified, default depends on the language and type. */\n    Unknown,\n\n    /** Used in Swift, member can be accessed outside of the defining module and extended. */\n    Open,\n\n    /** Like Open, but in Swift such a type cannot be extended. */\n    Public,\n\n    /** Member is only accessible in the defining class and any derived class. */\n    Protected,\n\n    /** Member can only be accessed from the defining class. */\n    Private,\n\n    /** Used in Swift, member can be accessed from everywhere in a defining module, not outside however. */\n    FilePrivate,\n\n    /** Custom enum for special usage. */\n    Library,\n}\n\nexport enum Modifier {\n    Static,\n    Final,\n    Sealed,\n    Abstract,\n    Deprecated,\n    Virtual,\n    Const,\n    Overwritten,\n}\n\n/** Rough categorization of a type. */\nexport enum TypeKind {\n    Unknown,\n\n    Integer,\n    Float,\n    Number,\n\n    String,\n    Char,\n\n    Boolean,\n\n    Class,\n    Interface,\n    Array,\n    Map,\n    Enum,\n\n    Alias,\n}\n\nexport enum ReferenceKind {\n    Irrelevant,\n\n    /** Default for most languages for dynamically allocated memory (\"Type*\" in C++). */\n    Pointer,\n\n    /** \"Type&\" in C++ */\n    Reference,\n\n    /** \"Type\" as such and default for all value types. */\n    Instance,\n}\n\n/** The root type interface. Used for typed symbols and type aliases. */\nexport interface Type {\n    name: string;\n\n    /**\n     * The super type of this type or empty if this is a fundamental type.\n     * Also used as the target type for type aliases.\n     */\n    baseTypes: Type[];\n    kind: TypeKind;\n    reference: ReferenceKind;\n}\n\nexport interface SymbolTableOptions {\n    allowDuplicateSymbols?: boolean;\n}\n\n/** A single class for all fundamental types. They are distinguished via the kind field. */\nexport class FundamentalType implements Type {\n    public static readonly integerType = new FundamentalType(\"int\", TypeKind.Integer, ReferenceKind.Instance);\n    public static readonly floatType = new FundamentalType(\"float\", TypeKind.Float, ReferenceKind.Instance);\n    public static readonly stringType = new FundamentalType(\"string\", TypeKind.String, ReferenceKind.Instance);\n    public static readonly boolType = new FundamentalType(\"bool\", TypeKind.Boolean, ReferenceKind.Instance);\n\n    public name: string;\n\n    private typeKind: TypeKind;\n    private referenceKind: ReferenceKind;\n\n    public constructor(name: string, typeKind = TypeKind.Unknown, referenceKind = ReferenceKind.Irrelevant) {\n        this.name = name;\n        this.typeKind = typeKind;\n        this.referenceKind = referenceKind;\n    }\n\n    public get baseTypes(): Type[] {\n        return [];\n    }\n\n    public get kind(): TypeKind {\n        return this.typeKind;\n    }\n\n    public get reference(): ReferenceKind {\n        return this.referenceKind;\n    }\n\n}\n\n/**\n * The root of the symbol table class hierarchy: a symbol can be any manageable entity (like a block), not only\n * things like variables or classes.\n * We are using a class hierarchy here, instead of an enum or similar, to allow for easy extension and certain\n * symbols can so provide additional APIs for simpler access to their sub elements, if needed.\n */\nexport class Symbol {\n    /** The name of the scope or empty if anonymous. */\n    public name = \"\";\n\n    /** Reference to the parse tree which contains this symbol. */\n    public context?: ParseTree;\n\n    public readonly modifiers = new Set<Modifier>();\n    public visibility = MemberVisibility.Unknown;\n\n    // eslint-disable-next-line no-use-before-define\n    private theParent?: Symbol;\n\n    public constructor(name = \"\") {\n        this.name = name;\n    }\n\n    public get parent(): Symbol | undefined {\n        return this.theParent;\n    }\n\n    public get firstSibling(): Symbol {\n        if (this.theParent instanceof ScopedSymbol) {\n            return this.theParent.firstChild!;\n        }\n\n        return this;\n    }\n\n    /**\n     * @returns the symbol before this symbol in its scope.\n     */\n    public get previousSibling(): Symbol | undefined {\n        if (!(this.theParent instanceof ScopedSymbol)) {\n            return this;\n        }\n\n        return this.theParent.previousSiblingOf(this);\n    }\n\n    /**\n     * @returns the symbol following this symbol in its scope.\n     */\n    public get nextSibling(): Symbol | undefined {\n        if (!(this.theParent instanceof ScopedSymbol)) {\n            return this;\n        }\n\n        return this.theParent.nextSiblingOf(this);\n    }\n\n    public get lastSibling(): Symbol {\n        if (this.theParent instanceof ScopedSymbol) {\n            return this.theParent.lastChild!;\n        }\n\n        return this;\n    }\n\n    /**\n     * @returns the next symbol in definition order, regardless of the scope.\n     */\n    public get next(): Symbol | undefined {\n        if (this.theParent instanceof ScopedSymbol) {\n            return this.theParent.nextOf(this);\n        }\n\n        return undefined;\n    }\n\n    /**\n     * @returns the outermost entity (below the symbol table) that holds us.\n     */\n    public get root(): Symbol | undefined {\n        let run = this.theParent;\n        while (run) {\n            if (!run.theParent || (run.theParent instanceof SymbolTable)) {\n                return run;\n            }\n            run = run.theParent;\n        }\n\n        return run;\n    }\n\n    /**\n     * @returns the symbol table we belong too or undefined if we are not yet assigned.\n     */\n    public get symbolTable(): SymbolTable | undefined {\n        if (this instanceof SymbolTable) {\n            return this;\n        }\n\n        let run = this.theParent;\n        while (run) {\n            if (run instanceof SymbolTable) {\n                return run;\n            }\n            run = run.theParent;\n        }\n\n        return undefined;\n    }\n\n    /**\n     * @returns the list of symbols from this one up to root.\n     */\n    public get symbolPath(): Symbol[] {\n        const result: Symbol[] = [];\n\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        let run: Symbol = this;\n        while (run) {\n            result.push(run);\n            if (!run.theParent) {\n                break;\n            }\n            run = run.theParent;\n        }\n\n        return result;\n    }\n\n    /**\n     * The parent is usually a scoped symbol as only those can have children, but we allow\n     * any symbol here for special scenarios.\n     * This is rather an internal method and should rarely be used by external code.\n     *\n     * @param parent The new parent to use.\n     */\n    public setParent(parent: Symbol | undefined): void {\n        this.theParent = parent;\n    }\n\n    public removeFromParent(): void {\n        if (this.theParent instanceof ScopedSymbol) {\n            this.theParent.removeSymbol(this);\n            this.theParent = undefined;\n        }\n    }\n\n    /**\n     * Asynchronously looks up a symbol with a given name, in a bottom-up manner.\n     *\n     * @param name The name of the symbol to find.\n     * @param localOnly If true only child symbols are returned, otherwise also symbols from the parent of this symbol\n     *                  (recursively).\n     *\n     * @returns A promise resolving to the first symbol with a given name, in the order of appearance in this scope\n     *          or any of the parent scopes (conditionally).\n     */\n    public async resolve(name: string, localOnly = false): Promise<Symbol | undefined> {\n        if (this.theParent instanceof ScopedSymbol) {\n            return this.theParent.resolve(name, localOnly);\n        }\n\n        return Promise.resolve(undefined);\n    }\n\n    /**\n     * Synchronously looks up a symbol with a given name, in a bottom-up manner.\n     *\n     * @param name The name of the symbol to find.\n     * @param localOnly If true only child symbols are returned, otherwise also symbols from the parent of this symbol\n     *                  (recursively).\n     *\n     * @returns the first symbol with a given name, in the order of appearance in this scope\n     *          or any of the parent scopes (conditionally).\n     */\n    public resolveSync(name: string, localOnly = false): Symbol | undefined {\n        if (this.theParent instanceof ScopedSymbol) {\n            return this.theParent.resolveSync(name, localOnly);\n        }\n\n        return undefined;\n    }\n\n    /**\n     * @param t The type of objects to return.\n     *\n     * @returns the next enclosing parent of the given type.\n     */\n    public getParentOfType<T extends Symbol>(t: new (...args: any[]) => T): T | undefined {\n        let run = this.theParent;\n        while (run) {\n            if (run instanceof t) { return run; }\n            run = run.theParent;\n        }\n\n        return undefined;\n    }\n\n    /**\n     * Creates a qualified identifier from this symbol and its parent.\n     * If `full` is true then all parents are traversed in addition to this instance.\n     *\n     * @param separator The string to be used between the parts.\n     * @param full A flag indicating if the full path is to be returned.\n     * @param includeAnonymous Use a special string for empty scope names.\n     *\n     * @returns the constructed qualified identifier.\n     */\n    public qualifiedName(separator = \".\", full = false, includeAnonymous = false): string {\n        if (!includeAnonymous && this.name.length === 0) {\n            return \"\";\n        }\n\n        let result: string = this.name.length === 0 ? \"<anonymous>\" : this.name;\n        let run = this.theParent;\n        while (run) {\n            if (includeAnonymous || run.name.length > 0) {\n                result = (run.name.length === 0 ? \"<anonymous>\" : run.name) + separator + result;\n            }\n\n            if (!full || !run.theParent) {\n                break;\n            }\n            run = run.theParent;\n        }\n\n        return result;\n    }\n\n}\n\n/** A symbol with an attached type (variables, fields etc.). */\nexport class TypedSymbol extends Symbol {\n    public type: Type | undefined;\n\n    public constructor(name: string, type?: Type) {\n        super(name);\n        this.type = type;\n    }\n}\n\n/** An alias for another type. */\nexport class TypeAlias extends Symbol implements Type {\n    private targetType: Type;\n\n    public constructor(name: string, target: Type) {\n        super(name);\n        this.targetType = target;\n    }\n\n    public get baseTypes(): Type[] {\n        return [this.targetType];\n    }\n\n    public get kind(): TypeKind {\n        return TypeKind.Alias;\n    }\n\n    public get reference(): ReferenceKind {\n        return ReferenceKind.Irrelevant;\n    }\n}\n\n/** A symbol with a scope (so it can have child symbols). */\nexport class ScopedSymbol extends Symbol {\n\n    /** All child symbols in definition order. */\n    private childSymbols: Symbol[] = [];\n\n    public constructor(name = \"\") {\n        super(name);\n    }\n\n    /**\n     * @returns A promise resolving to all direct child symbols with a scope (e.g. classes in a module).\n     */\n    public get directScopes(): Promise<ScopedSymbol[]> {\n        return this.getSymbolsOfType(ScopedSymbol);\n    }\n\n    public get children(): Symbol[] {\n        return this.childSymbols;\n    }\n\n    public get firstChild(): Symbol | undefined {\n        if (this.children.length > 0) {\n            return this.children[0];\n        }\n\n        return undefined;\n    }\n\n    public get lastChild(): Symbol | undefined {\n        if (this.children.length > 0) {\n            return this.children[this.children.length - 1];\n        }\n\n        return undefined;\n    }\n\n    public clear(): void {\n        this.childSymbols = [];\n    }\n\n    /**\n     * Adds the given symbol to this scope. If it belongs already to a different scope\n     * it is removed from that before adding it here.\n     *\n     * @param symbol The symbol to add as a child.\n     */\n    public addSymbol(symbol: Symbol): void {\n        symbol.removeFromParent();\n\n        // Check for duplicates first.\n        const symbolTable = this.symbolTable;\n        if (!symbolTable || !symbolTable.options.allowDuplicateSymbols) {\n            this.children.forEach((child) => {\n                if (child === symbol || (symbol.name.length > 0 && child.name === symbol.name)) {\n                    let name = symbol.name;\n                    if (name.length === 0) {\n                        name = \"<anonymous>\";\n                    }\n\n                    throw new DuplicateSymbolError(\"Attempt to add duplicate symbol '\" + name + \"'\");\n                }\n            });\n        }\n\n        this.children.push(symbol);\n        symbol.setParent(this);\n    }\n\n    public removeSymbol(symbol: Symbol): void {\n        const index = this.children.indexOf(symbol);\n        if (index > -1) {\n            this.children.splice(index, 1);\n            symbol.setParent(undefined);\n        }\n    }\n\n    /**\n     * Asynchronously retrieves child symbols of a given type from this symbol.\n     *\n     * @param t The type of of the objects to return.\n     *\n     * @returns A promise resolving to all (nested) children of the given type.\n     */\n    public async getNestedSymbolsOfType<T extends Symbol>(t: new (...args: any[]) => T): Promise<T[]> {\n        const result: T[] = [];\n\n        const childPromises: Array<Promise<T[]>> = [];\n        this.children.forEach((child) => {\n            if (child instanceof t) {\n                result.push(child);\n            }\n\n            if (child instanceof ScopedSymbol) {\n                childPromises.push(child.getNestedSymbolsOfType(t));\n            }\n        });\n        const childSymbols = await Promise.all(childPromises);\n        childSymbols.forEach((entry) => {\n            result.push(...entry);\n        });\n\n        return result;\n    }\n\n    /**\n     * Synchronously retrieves child symbols of a given type from this symbol.\n     *\n     * @param t The type of of the objects to return.\n     *\n     * @returns A list of all (nested) children of the given type.\n     */\n    public getNestedSymbolsOfTypeSync<T extends Symbol>(t: new (...args: any[]) => T): T[] {\n        const result: T[] = [];\n\n        this.children.forEach((child) => {\n            if (child instanceof t) {\n                result.push(child);\n            }\n\n            if (child instanceof ScopedSymbol) {\n                result.push(...child.getNestedSymbolsOfTypeSync(t));\n            }\n        });\n\n        return result;\n    }\n\n    /**\n     * @param name If given only returns symbols with that name.\n     *\n     * @returns A promise resolving to symbols from this and all nested scopes in the order they were defined.\n     */\n    public async getAllNestedSymbols(name?: string): Promise<Symbol[]> {\n        const result: Symbol[] = [];\n\n        const childPromises: Array<Promise<Symbol[]>> = [];\n        this.children.forEach((child) => {\n            if (!name || child.name === name) {\n                result.push(child);\n            }\n\n            if (child instanceof ScopedSymbol) {\n                childPromises.push(child.getAllNestedSymbols(name));\n            }\n        });\n        const childSymbols = await Promise.all(childPromises);\n        childSymbols.forEach((entry) => {\n            result.push(...entry);\n        });\n\n        return result;\n    }\n\n    /**\n     * @param name If given only returns symbols with that name.\n     *\n     * @returns A list of all symbols from this and all nested scopes in the order they were defined.\n     */\n    public getAllNestedSymbolsSync(name?: string): Symbol[] {\n        const result: Symbol[] = [];\n\n        this.children.forEach((child) => {\n            if (!name || child.name === name) {\n                result.push(child);\n            }\n\n            if (child instanceof ScopedSymbol) {\n                result.push(...child.getAllNestedSymbolsSync(name));\n            }\n        });\n\n        return result;\n    }\n\n    /**\n     * @param t The type of of the objects to return.\n     *\n     * @returns A promise resolving to direct children of a given type.\n     */\n    public getSymbolsOfType<T extends Symbol>(t: new (...args: any[]) => T): Promise<T[]> {\n        return new Promise((resolve) => {\n            const result: T[] = [];\n            this.children.forEach((child) => {\n                if (child instanceof t) {\n                    result.push(child);\n                }\n            });\n\n            resolve(result);\n        });\n    }\n\n    /**\n     * TODO: add optional position dependency (only symbols defined before a given caret pos are viable).\n     *\n     * @param t The type of the objects to return.\n     * @param localOnly If true only child symbols are returned, otherwise also symbols from the parent of this symbol\n     *                  (recursively).\n     *\n     * @returns A promise resolving to all symbols of the the given type, accessible from this scope (if localOnly is\n     *          false), within the owning symbol table.\n     */\n    public async getAllSymbols<T extends Symbol>(t: new (...args: any[]) => T, localOnly = false): Promise<T[]> {\n        const result: T[] = [];\n\n        // Special handling for namespaces, which act like grouping symbols in this scope,\n        // so we show them as available in this scope.\n        for (const child of this.children) {\n            if (child instanceof t) {\n                result.push(child);\n            }\n\n            if (child instanceof NamespaceSymbol) {\n                const childSymbols = await child.getAllSymbols(t, true);\n                result.push(...childSymbols);\n            }\n        }\n\n        if (!localOnly) {\n            if (this.parent instanceof ScopedSymbol) {\n                const childSymbols = await this.getAllSymbols(t, true);\n                result.push(...childSymbols);\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * TODO: add optional position dependency (only symbols defined before a given caret pos are viable).\n     *\n     * @param t The type of the objects to return.\n     * @param localOnly If true only child symbols are returned, otherwise also symbols from the parent of this symbol\n     *                  (recursively).\n     *\n     * @returns A list with all symbols of the the given type, accessible from this scope (if localOnly is\n     *          false), within the owning symbol table.\n     */\n    public getAllSymbolsSync<T extends Symbol>(t: new (...args: any[]) => T, localOnly = false): T[] {\n        const result: T[] = [];\n\n        // Special handling for namespaces, which act like grouping symbols in this scope,\n        // so we show them as available in this scope.\n        for (const child of this.children) {\n            if (child instanceof t) {\n                result.push(child);\n            }\n\n            if (child instanceof NamespaceSymbol) {\n                const childSymbols = child.getAllSymbolsSync(t, true);\n                result.push(...childSymbols);\n            }\n        }\n\n        if (!localOnly) {\n            if (this.parent instanceof ScopedSymbol) {\n                const childSymbols = this.getAllSymbolsSync(t, true);\n                result.push(...childSymbols);\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * @param name The name of the symbol to resolve.\n     * @param localOnly If true only child symbols are returned, otherwise also symbols from the parent of this symbol\n     *                  (recursively).\n     *\n     * @returns A promise resolving to the first symbol with a given name, in the order of appearance in this scope\n     *          or any of the parent scopes (conditionally).\n     */\n    public async resolve(name: string, localOnly = false): Promise<Symbol | undefined> {\n        return new Promise((resolve, reject) => {\n            for (const child of this.children) {\n                if (child.name === name) {\n                    resolve(child);\n\n                    return;\n                }\n            }\n\n            // Nothing found locally. Let the parent continue.\n            if (!localOnly) {\n                if (this.parent instanceof ScopedSymbol) {\n                    resolve(this.parent.resolve(name, false));\n\n                    return;\n                }\n            }\n\n            resolve(undefined);\n        });\n    }\n\n    /**\n     * @param name The name of the symbol to resolve.\n     * @param localOnly If true only child symbols are returned, otherwise also symbols from the parent of this symbol\n     *                  (recursively).\n     *\n     * @returns the first symbol with a given name, in the order of appearance in this scope\n     *          or any of the parent scopes (conditionally).\n     */\n    public resolveSync(name: string, localOnly = false): Symbol | undefined {\n        for (const child of this.children) {\n            if (child.name === name) {\n                return child;\n            }\n        }\n\n        // Nothing found locally. Let the parent continue.\n        if (!localOnly) {\n            if (this.parent instanceof ScopedSymbol) {\n                return this.parent.resolveSync(name, false);\n\n            }\n        }\n\n        return undefined;\n    }\n\n    /**\n     * @param localOnly If true only child symbols are returned, otherwise also symbols from the parent of this symbol\n     *                  (recursively).\n     *\n     * @returns all accessible symbols that have a type assigned.\n     */\n    public getTypedSymbols(localOnly = true): TypedSymbol[] {\n        const result: TypedSymbol[] = [];\n\n        for (const child of this.children) {\n            if (child instanceof TypedSymbol) {\n                result.push(child);\n            }\n        }\n\n        if (!localOnly) {\n            if (this.parent instanceof ScopedSymbol) {\n                const localList = this.parent.getTypedSymbols(true);\n                result.push(...localList);\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * The names of all accessible symbols with a type.\n     *\n     * @param localOnly If true only child symbols are returned, otherwise also symbols from the parent of this symbol\n     *                  (recursively).\n     *\n     * @returns A list of names.\n     */\n    public getTypedSymbolNames(localOnly = true): string[] {\n        const result: string[] = [];\n        for (const child of this.children) {\n            if (child instanceof TypedSymbol) {\n                result.push(child.name);\n            }\n        }\n\n        if (!localOnly) {\n            if (this.parent instanceof ScopedSymbol) {\n                const localList = (this.parent).getTypedSymbolNames(true);\n                result.push(...localList);\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * @param path The path consisting of symbol names separator by `separator`.\n     * @param separator The character to separate path segments.\n     *\n     * @returns the symbol located at the given path through the symbol hierarchy.\n     */\n    public symbolFromPath(path: string, separator = \".\"): Symbol | undefined {\n        const elements = path.split(separator);\n        let index = 0;\n        if (elements[0] === this.name || elements[0].length === 0) {\n            ++index;\n        }\n\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        let result: Symbol = this;\n        while (index < elements.length) {\n            if (!(result instanceof ScopedSymbol)) {\n                return undefined;\n            }\n\n            // eslint-disable-next-line no-loop-func\n            const child = result.children.find((candidate) => candidate.name === elements[index]);\n            if (!child) {\n                return undefined;\n            }\n\n            result = child;\n            ++index;\n        }\n\n        return result;\n    }\n\n    /**\n     * @param child The child to search for.\n     *\n     * @returns the index of the given child symbol in the child list or -1 if it couldn't be found.\n     */\n    public indexOfChild(child: Symbol): number {\n        return this.children.findIndex((value: Symbol, index: number) => value === child);\n    }\n\n    /**\n     * @param child The reference node.\n     *\n     * @returns the sibling symbol after the given child symbol, if one exists.\n     */\n    public nextSiblingOf(child: Symbol): Symbol | undefined {\n        const index = this.indexOfChild(child);\n        if (index === -1 || index >= this.children.length - 1) {\n            return undefined;\n        }\n\n        return this.children[index + 1];\n    }\n\n    /**\n     * @param child The reference node.\n     *\n     * @returns the sibling symbol before the given child symbol, if one exists.\n     */\n    public previousSiblingOf(child: Symbol): Symbol | undefined {\n        const index = this.indexOfChild(child);\n        if (index < 1) {\n            return undefined;\n        }\n\n        return this.children[index - 1];\n    }\n\n    /**\n     * @param child The reference node.\n     *\n     * @returns the next symbol in definition order, regardless of the scope.\n     */\n    public nextOf(child: Symbol): Symbol | undefined {\n        if (!(child.parent instanceof ScopedSymbol)) {\n            return undefined;\n        }\n\n        if (child.parent !== this) {\n            return child.parent.nextOf(child);\n        }\n\n        if (child instanceof ScopedSymbol && child.children.length > 0) {\n            return child.children[0];\n        }\n\n        const sibling = this.nextSiblingOf(child);\n        if (sibling) {\n            return sibling;\n        }\n\n        return (this.parent as ScopedSymbol).nextOf(this);\n    }\n}\n\nexport class NamespaceSymbol extends ScopedSymbol {\n}\n\nexport class BlockSymbol extends ScopedSymbol {\n}\n\nexport class VariableSymbol extends TypedSymbol {\n\n    public value: any;\n\n    public constructor(name: string, value: any, type?: Type) {\n        super(name, type);\n\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        this.value = value;\n    }\n}\n\nexport class LiteralSymbol extends TypedSymbol {\n    public readonly value: any;\n\n    public constructor(name: string, value: any, type?: Type) {\n        super(name, type);\n\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        this.value = value;\n    }\n}\n\nexport class ParameterSymbol extends VariableSymbol { }\n\n// A standalone function/procedure/rule.\nexport class RoutineSymbol extends ScopedSymbol {\n    public returnType?: Type; // Can be null if result is void.\n\n    public constructor(name: string, returnType: Type) {\n        super(name);\n        this.returnType = returnType;\n    }\n\n    public getVariables(localOnly = true): Promise<VariableSymbol[]> {\n        return this.getSymbolsOfType(VariableSymbol);\n    }\n\n    public getParameters(localOnly = true): Promise<ParameterSymbol[]> {\n        return this.getSymbolsOfType(ParameterSymbol);\n    }\n}\n\nexport enum MethodFlags {\n    None = 0,\n    Virtual = 1,\n    Const = 2,\n    Overwritten = 4,\n\n    /** Distinguished by the return type. */\n    SetterOrGetter = 8,\n\n    /** Special flag used e.g. in C++ for explicit c-tors. */\n    Explicit = 16,\n}\n\n\n/** A function which belongs to a class or other outer container structure. */\nexport class MethodSymbol extends RoutineSymbol {\n    public methodFlags = MethodFlags.None;\n}\n\n/** A field which belongs to a class or other outer container structure. */\nexport class FieldSymbol extends VariableSymbol {\n    public setter?: MethodSymbol;\n    public getter?: MethodSymbol;\n}\n\n/** Classes and structs. */\nexport class ClassSymbol extends ScopedSymbol implements Type {\n    public isStruct = false;\n    public reference = ReferenceKind.Irrelevant;\n\n    /** Usually only one member, unless the language supports multiple inheritance (like C++). */\n    // eslint-disable-next-line no-use-before-define\n    public readonly extends: ClassSymbol[];\n\n    /** Typescript allows a class to implement a class, not only interfaces. */\n    // eslint-disable-next-line no-use-before-define\n    public readonly implements: Array<ClassSymbol | InterfaceSymbol>;\n\n    public constructor(name: string, ext: ClassSymbol[], impl: Array<ClassSymbol | InterfaceSymbol>) {\n        super(name);\n        this.extends = ext;\n        this.implements = impl;\n    }\n\n    public get baseTypes(): Type[] { return this.extends; }\n    public get kind(): TypeKind { return TypeKind.Class; }\n\n    /**\n     * @param includeInherited Not used.\n     *\n     * @returns a list of all methods.\n     */\n    public getMethods(includeInherited = false): Promise<MethodSymbol[]> {\n        return this.getSymbolsOfType(MethodSymbol);\n    }\n\n    /**\n     * @param includeInherited Not used.\n     *\n     * @returns all fields.\n     */\n    public getFields(includeInherited = false): Promise<FieldSymbol[]> {\n        return this.getSymbolsOfType(FieldSymbol);\n    }\n}\n\nexport class InterfaceSymbol extends ScopedSymbol implements Type {\n    public reference = ReferenceKind.Irrelevant;\n\n    /** Typescript allows an interface to extend a class, not only interfaces. */\n    // eslint-disable-next-line no-use-before-define\n    public readonly extends: Array<ClassSymbol | InterfaceSymbol>;\n\n    public constructor(name: string, ext: Array<ClassSymbol | InterfaceSymbol>) {\n        super(name);\n        this.extends = ext;\n    }\n\n    public get baseTypes(): Type[] { return this.extends; }\n    public get kind(): TypeKind { return TypeKind.Interface; }\n\n    /**\n     * @param includeInherited Not used.\n     *\n     * @returns a list of all methods.\n     */\n    public getMethods(includeInherited = false): Promise<MethodSymbol[]> {\n        return this.getSymbolsOfType(MethodSymbol);\n    }\n\n    /**\n     * @param includeInherited Not used.\n     *\n     * @returns all fields.\n     */\n    public getFields(includeInherited = false): Promise<FieldSymbol[]> {\n        return this.getSymbolsOfType(FieldSymbol);\n    }\n}\n\nexport class ArrayType extends Symbol implements Type {\n\n    public readonly elementType: Type;\n    public readonly size: number; // > 0 if fixed length.\n\n    private referenceKind: ReferenceKind;\n\n    public constructor(name: string, referenceKind: ReferenceKind, elemType: Type, size = 0) {\n        super(name);\n        this.referenceKind = referenceKind;\n        this.elementType = elemType;\n        this.size = size;\n    }\n\n    public get baseTypes(): Type[] { return []; }\n    public get kind(): TypeKind { return TypeKind.Array; }\n    public get reference(): ReferenceKind { return this.referenceKind; }\n}\n\n/** The main class managing all the symbols for a top level entity like a file, library or similar. */\nexport class SymbolTable extends ScopedSymbol {\n    /**  Other symbol information available to this instance. */\n    // eslint-disable-next-line no-use-before-define\n    protected dependencies: Set<SymbolTable> = new Set();\n\n    public constructor(name: string, public readonly options: SymbolTableOptions) {\n        super(name);\n    }\n\n    /**\n     * @returns instance information, mostly relevant for unit testing.\n     */\n    public get info() {\n        return {\n            dependencyCount: this.dependencies.size,\n            symbolCount: this.children.length,\n        };\n    }\n\n    public clear() {\n        super.clear();\n        this.dependencies.clear();\n    }\n\n    public addDependencies(...tables: SymbolTable[]) {\n        tables.forEach((value, key) => {\n            this.dependencies.add(value);\n        });\n    }\n\n    public removeDependency(table: SymbolTable) {\n        if (this.dependencies.has(table)) {\n            this.dependencies.delete(table);\n        }\n    }\n\n    public addNewSymbolOfType<T extends Symbol>(t: new (...args: any[]) => T,\n        parent: ScopedSymbol | undefined, ...args: any[]): T {\n\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n        const result = new t(...args);\n        if (!parent || parent === this) {\n            this.addSymbol(result);\n        } else {\n            parent.addSymbol(result);\n        }\n\n        return result;\n    }\n\n    /**\n     * Asynchronously adds a new namespace to the symbol table or the given parent. The path parameter specifies a\n     * single namespace name or a chain of namespaces (which can be e.g. \"outer.intermittent.inner.final\").\n     * If any of the parent namespaces is missing they are created implicitly. The final part must not exist however\n     * or you'll get a duplicate symbol error.\n     *\n     * @param parent The parent to add the namespace to.\n     * @param path The namespace path.\n     * @param delimiter The delimiter used in the path.\n     *\n     * @returns The new symbol.\n     */\n    public async addNewNamespaceFromPath(parent: ScopedSymbol | undefined, path: string,\n        delimiter = \".\"): Promise<NamespaceSymbol> {\n        const parts = path.split(delimiter);\n        let i = 0;\n        let currentParent = (parent === undefined) ? this : parent;\n        while (i < parts.length - 1) {\n            let namespace = await currentParent.resolve(parts[i], true) as NamespaceSymbol;\n            if (namespace === undefined) {\n                namespace = this.addNewSymbolOfType(NamespaceSymbol, currentParent, parts[i]);\n            }\n            currentParent = namespace;\n            ++i;\n        }\n\n        return this.addNewSymbolOfType(NamespaceSymbol, currentParent, parts[parts.length - 1]);\n    }\n\n    /**\n     * Synchronously adds a new namespace to the symbol table or the given parent. The path parameter specifies a\n     * single namespace name or a chain of namespaces (which can be e.g. \"outer.intermittent.inner.final\").\n     * If any of the parent namespaces is missing they are created implicitly. The final part must not exist however\n     * or you'll get a duplicate symbol error.\n     *\n     * @param parent The parent to add the namespace to.\n     * @param path The namespace path.\n     * @param delimiter The delimiter used in the path.\n     *\n     * @returns The new symbol.\n     */\n    public addNewNamespaceFromPathSync(parent: ScopedSymbol | undefined, path: string,\n        delimiter = \".\"): NamespaceSymbol {\n        const parts = path.split(delimiter);\n        let i = 0;\n        let currentParent = (parent === undefined) ? this : parent;\n\n        while (i < parts.length - 1) {\n            let namespace = currentParent.resolveSync(parts[i], true) as NamespaceSymbol;\n            if (namespace === undefined) {\n                namespace = this.addNewSymbolOfType(NamespaceSymbol, currentParent, parts[i]);\n            }\n            currentParent = namespace;\n            ++i;\n        }\n\n        return this.addNewSymbolOfType(NamespaceSymbol, currentParent, parts[parts.length - 1]);\n    }\n\n    /**\n     * Asynchronously returns all symbols from this scope (and optionally those from dependencies) of a specific type.\n     *\n     * @param t The type of the symbols to return.\n     * @param localOnly If true do not search dependencies.\n     *\n     * @returns A promise which resolves when all symbols are collected.\n     */\n    public async getAllSymbols<T extends Symbol>(t: new (...args: any[]) => T, localOnly = false): Promise<T[]> {\n        const result: T[] = await super.getAllSymbols(t, localOnly);\n\n        if (!localOnly) {\n            const dependencyResults = await Promise.all([...this.dependencies].map((dependency) => (\n                dependency.getAllSymbols(t, localOnly)\n            )));\n\n            dependencyResults.forEach((value) => {\n                result.push(...value);\n            });\n        }\n\n        return result;\n    }\n\n    /**\n     * Synchronously returns all symbols from this scope (and optionally those from dependencies) of a specific type.\n     *\n     * @param t The type of the symbols to return.\n     * @param localOnly If true do not search dependencies.\n     *\n     * @returns A list with all symbols.\n     */\n    public getAllSymbolsSync<T extends Symbol>(t: new (...args: any[]) => T, localOnly = false): T[] {\n        const result: T[] = super.getAllSymbolsSync(t, localOnly);\n\n        if (!localOnly) {\n            this.dependencies.forEach((dependency) => {\n                result.push(...dependency.getAllSymbolsSync(t, localOnly));\n            });\n        }\n\n        return result;\n    }\n\n    /**\n     * Asynchronously looks for a symbol which is connected with a given parse tree context.\n     *\n     * @param context The context to search for.\n     *\n     * @returns A promise resolving to the found symbol or undefined.\n     */\n    public async symbolWithContext(context: ParseTree): Promise<Symbol | undefined> {\n        /**\n         * Local function to find a symbol recursively.\n         *\n         * @param symbol The symbol to search through.\n         *\n         * @returns The symbol with the given context, if found.\n         */\n        const findRecursive = (symbol: Symbol): Symbol | undefined => {\n            if (symbol.context === context) {\n                return symbol;\n            }\n\n            if (symbol instanceof ScopedSymbol) {\n                for (const child of symbol.children) {\n                    const result = findRecursive(child);\n                    if (result) {\n                        return result;\n                    }\n                }\n            }\n\n            return undefined;\n        };\n\n\n        let symbols = await this.getAllSymbols(Symbol);\n        for (const symbol of symbols) {\n            const result = findRecursive(symbol);\n            if (result) {\n                return result;\n            }\n        }\n\n        for (const dependency of this.dependencies) {\n            symbols = await dependency.getAllSymbols(Symbol);\n            for (const symbol of symbols) {\n                const result = findRecursive(symbol);\n                if (result) {\n                    return result;\n                }\n            }\n        }\n\n        return undefined;\n    }\n\n    /**\n     * Synchronously looks for a symbol which is connected with a given parse tree context.\n     *\n     * @param context The context to search for.\n     *\n     * @returns The found symbol or undefined.\n     */\n    public symbolWithContextSync(context: ParseTree): Symbol | undefined {\n        /**\n         * Local function to find a symbol recursively.\n         *\n         * @param symbol The symbol to search through.\n         *\n         * @returns The symbol with the given context, if found.\n         */\n        const findRecursive = (symbol: Symbol): Symbol | undefined => {\n            if (symbol.context === context) {\n                return symbol;\n            }\n\n            if (symbol instanceof ScopedSymbol) {\n                for (const child of symbol.children) {\n                    const result = findRecursive(child);\n                    if (result) {\n                        return result;\n                    }\n                }\n            }\n\n            return undefined;\n        };\n\n\n        let symbols = this.getAllSymbolsSync(Symbol);\n        for (const symbol of symbols) {\n            const result = findRecursive(symbol);\n            if (result) {\n                return result;\n            }\n        }\n\n        for (const dependency of this.dependencies) {\n            symbols = dependency.getAllSymbolsSync(Symbol);\n            for (const symbol of symbols) {\n                const result = findRecursive(symbol);\n                if (result) {\n                    return result;\n                }\n            }\n        }\n\n        return undefined;\n    }\n\n    /**\n     * Asynchronously resolves a name to a symbol.\n     *\n     * @param name The name of the symbol to find.\n     * @param localOnly A flag indicating if only this symbol table should be used or also its dependencies.\n     *\n     * @returns A promise resolving to the found symbol or undefined.\n     */\n    public async resolve(name: string, localOnly = false): Promise<Symbol | undefined> {\n        let result = await super.resolve(name, localOnly);\n        if (!result && !localOnly) {\n            for (const dependency of this.dependencies) {\n                result = await dependency.resolve(name, false);\n                if (result) {\n                    return result;\n                }\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Synchronously resolves a name to a symbol.\n     *\n     * @param name The name of the symbol to find.\n     * @param localOnly A flag indicating if only this symbol table should be used or also its dependencies.\n     *\n     * @returns The found symbol or undefined.\n     */\n    public resolveSync(name: string, localOnly = false): Symbol | undefined {\n        let result = super.resolveSync(name, localOnly);\n        if (!result && !localOnly) {\n            for (const dependency of this.dependencies) {\n                result = dependency.resolveSync(name, false);\n                if (result) {\n                    return result;\n                }\n            }\n        }\n\n        return result;\n    }\n\n}\n"]}